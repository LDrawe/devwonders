<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta name="theme-color" content="#54342f">
    <link rel="icon" href="../public/icons/favicon.svg" type="image/x-icon">
    <link rel="stylesheet" href="../css/global.css">
    <link rel="stylesheet" href="../css/styles.css">
    <link rel="stylesheet" href="../css/rainbow.css">
    <script src="../js/nav.js" defer></script>
    <script src="../js/rainbow.js" defer></script>
    <script src="../js/formatter.js" defer></script>
    <script src="../js/sidebar.js" defer></script>
    <title>DevWonders</title>
</head>

<body>
    <header>
        <a href="../index.html">
            <h1>DevWonders</h1>
            <img src="../public/icons/favicon.svg" alt="Logo">
        </a>
        <img src="../public/icons/js.svg" alt="Javascript">
        <nav>
            <ul>
                <li><a style="--color: var(--html)" href="html.html">HTML</a></li>
                <li><a style="--color: var(--css)" href="css.html">CSS</a></li>
                <li><a style="--color: var(--js)" href="js.html">JavaScript</a></li>
            </ul>
        </nav>
        <button id="btn-mobile" title="Menu" type="button">
        </button>
    </header>
    <main>
        <nav>
            <ul>
            </ul>
        </nav>
        <article>
            <button id="rtn-btn" title="Return to top" type="button">
                <img src="../public/icons/up.svg" alt="Return to top" height="30">
            </button>
            <button id="sidebar-Control" title="Toggle sidebar" type="button">
                <span></span>
            </button>
            <section>
                <h2>
                    Big Numbers
                </h2>
                <p>
                    Small numbers are easy and quick to read. But what about large ones? Let's say
                    1000000.
                    You probably have seen a large number like this while coding. Thankfully, javascript has
                    a way to make these more readable, you can use underlines to separate into groups for better readability
                </p>
                <div>
                    <div>
                        <div class="language-control">
                            <span></span>
                        </div>
                        <pre>
                            <code class="code-block" data-language="javascript">
                                console.log(1_000_000)
                            </code>
                        </pre>
                    </div>
                </div>
            </section>
            <section>
                <h2>
                    Delete
                </h2>
                <p>
                    If you have an object and need to delete a property from it, you may be tempted to use the <span class="keyword">delete</span>
                    keyword. And that's fine, but you can solve this in a more elegant and safer way by using
                    destructuring.
                </p>
                <div>
                    <div>
                        <div class="language-control">
                            <span></span>
                        </div>
                        <pre>
                            <code class="code-block" data-language="javascript">
                                const foo = {
                                    positionX: 50,
                                    positionY: 20,
                                    positionZ: 2
                                }
                                const { positionX, ...bar } = foo
                                console.log(bar)
                            </code>
                        </pre>
                    </div>
                </div>
            </section>
            <section>
                <h2>
                    isNan
                </h2>
                <p>
                    The <span class="keyword">isNan</span> function in JavaScript is used to determine if a value is Not a Number (NaN). It's
                    important to distinguish between NaN and other <span class="keyword">falsy</span> values like 0, empty strings, and false. For example, if we use the bang operator to check for a valid input, because javascript sees 0 as a <span class="keyword">falsy</span> value, it would flip a <span class="keyword">falsy</span> value to <span class="keyword truthy">true</span>, even if it's a valid one in our scenario. That's when you should use the isNan function
                </p>
                <div>
                    <div>
                        <div class="language-control">
                            <span></span>
                        </div>
                        <pre>
                            <code class="code-block" data-language="javascript">
                                let numberOfMessages = 0
                                // This would execute, even though is a valid input 
                                if(!numberOfMessages) {
                                    console.error('Error: Undefined value')
                                    return
                                }
                            </code>
                        </pre>
                    </div>
                    <div class="attach-top">
                        <div class="language-control">
                            <span></span>
                        </div>
                        <pre>
                            <code class="code-block" data-language="javascript">
                                let numberOfMessages = 0
                                if(isNan(numberOfMessages)) {
                                    console.error('Error: Undefined value')
                                    return
                                }
                                console.log('You have unread messages!')
                            </code>
                        </pre>
                    </div>
                </div>
            </section>
            <section>
                <h2>
                    Nullish Coalescing
                </h2>
                <p>
                    The logical <span class="keyword">OR</span> operator (<span class="keyword">||</span>) is used extensively to provide default values or check for truthy
                    conditions. Developers often rely on it because of its simplicity. However, the <span class="keyword">OR</span> operator can
                    sometimes lead to unexpected behavior, especially when dealing with the number 0
                </p>
                <div>
                    <div>
                        <div class="language-control">
                            <span></span>
                        </div>
                        <pre>
                            <code class="code-block" data-language="javascript">
                                let tax = 0

                                const reward = tax || 10 // Default tax is none is given
                                console.log(tax) // Output: 10 
                            </code>
                        </pre>
                    </div>
                </div>
                <p>
                    The intention here is to provide a base tax (10 dollars) if no values is passed. But the <span class="keyword">OR</span> operator sees the tax ammount as <span class="keyword">falsy</span> (because it's 0) and assigns the default value (10). This can be a bug if you actually want the code to recognize 0 as a valid score and not provide a reward. This is when the <span class="keyword">??</span> operator comes in hand. It checks if the value on the left side is either <span class="keyword">null</span> or <span class="keyword">undefined</span>. If it is, then it uses the value on the right side. This makes it perfect for setting defaults without getting tripped up by <span class="keyword">falsy</span> values like 0
                </p>
                <div>
                    <div>
                        <div class="language-control">
                            <span></span>
                        </div>
                        <pre>
                            <code class="code-block" data-language="javascript">
                                let tax = 0

                                const reward = tax ?? 10
                                console.log(tax) // Output: 0 
                            </code>
                        </pre>
                    </div>
                </div>
            </section>
            <section>
                <h2>
                    Optional chaining
                </h2>
                <p>
                    Optional chaining is a powerful feature introduced in ES6+ that allows you to safely
                    access nested properties within an object. It avoids long if statement to check for the properties individually and errors when dealing with potentially
                    undefined values in the chain.
                </p>
                <div>
                    <div>
                        <div class="language-control">
                            <span></span>
                        </div>
                        <pre>
                            <code class="code-block" data-language="javascript">
                                const user = {
                                    name: 'Alice',
                                    address: {
                                      street: '123 Main St',
                                      state: 'California'
                                    },
                                  }
                                  
                                // Even if property is undefined, it's safe to access
                                const street = user?.address?.street
                                console.log(street) // Output: "123 Main St" 
                            </code>
                        </pre>
                    </div>
                </div>
            </section>
            <section>
                <h2>
                    Inline catch
                </h2>
                <p>
                    When dealing with code that has promises, developers tend to encapsulate the entire block in a <span class="keyword">Try/Catch</span> block to prevent any errors. But when dealing with simple promises, this becomes unnecessary and adds a bit of nesting too. Instead, if it's a simple error treating, you can just catch it
                </p>
                <div>
                    <div>
                        <div class="language-control">
                            <span></span>
                        </div>
                        <pre>
                            <code class="code-block" data-language="javascript">
                                const data = fetch('google.com').catch(error => console.error(error))
                            </code>
                        </pre>
                    </div>
                </div>
            </section>
            <section>
                <h2>
                    Block scope
                </h2>
                <p>
                    Variables declared within a block are only accessible from within that specific block. This creates a well-defined scope for each variable, preventing unintended interactions with identically named variables in other parts of your code.
                </p>
                <div>
                    <div>
                        <div class="language-control">
                            <span></span>
                        </div>
                        <pre>
                            <code class="code-block" data-language="javascript">
                                let count = 5
                                {
                                    let count = 0
                                    console.log(count) // Output: 0
                                }
                                console.log(count) // Output: 5
                            </code>
                        </pre>
                    </div>
                </div>
            </section>
            <section>
                <h2>
                    In Keyword
                </h2>
                <p>
                    The <span class="keyword">in</span> keyword is a handy operator in JavaScript that checks if a property exists as a key within an object.
                </p>
                <div>
                    <div>
                        <div class="language-control">
                            <span></span>
                        </div>
                        <pre>
                            <code class="code-block" data-language="javascript">
                                const person = { name: 'Alice', age: 30 }
                                console.log('name' in person) // true
                                console.log('city' in person) // false
                            </code>
                        </pre>
                    </div>
                </div>
            </section>
            <section>
                <h2>
                    Dynamic Import
                </h2>
                <p>
                    Imagine a scenario where you only want to load specific code based on certain
                    conditions. JavaScript's dynamic import functionality allows you to import modules at runtime.
                </p>
                <div>
                    <div>
                        <div class="language-control">
                            <span></span>
                        </div>
                        <pre>
                            <code class="code-block" data-language="javascript">
                                if(userIsAdmin) {
                                    const lazyModule = await import('./admin.js')
                                }
                            </code>
                        </pre>
                    </div>
                </div>
            </section>
            <section>
                <h2>
                    Promise.all
                </h2>
                <p>
                    Waiting for multiple asynchronous operations can be sometimes inneficient.Let's say you have to fetch a list of users and posts from an api. The data retrived from one is not necessary to fetch the other.
                    <br>
                    <span class="keyword">Promise.all()</span> helps you get both results at once: It allows you to execute them
                    in parallel and provides a single promise that resolves when all the individual promises have
                    resolved.
                </p>
                <div>
                    <div>
                        <div class="language-control">
                            <span></span>
                        </div>
                        <pre>
                            <code class="code-block" data-language="javascript">
                                /* We're waiting users to finish before fetching the posts
                                Even if we don't need the users data to fetch posts */
                                const users = await fetch('https://api.example.com/users/')
                                const posts = await fetch('https://api.example.com/posts/')
                                
                                const [users, posts] = await Promise.all([
                                    fetch('https://api.example.com/users/'),
                                    fetch('https://api.example.com/posts/')
                                ])
                            </code>
                        </pre>
                    </div>
                </div>
            </section>
            <section>
                <h2>
                    Object.groupBy
                </h2>
                <p>
                    <span class="keyword">Object.groupBy()</span> allows you to categorize these objects based on a specific property. The end result is an object organized in groups. Let's take an example, you have a array of products and want to separate them between cheap and expensive:
                </p>
                <div>
                    <div>
                        <div class="language-control">
                            <span></span>
                        </div>
                        <pre>
                            <code class="code-block" data-language="javascript">
                                const products = [
                                    { name: 'Laptop', price: 500.00 },
                                    { name: 'Mug', price: 27.50 },
                                    { name: 'Headphones', price: 199.99 },
                                    { name: 'Fork', price: 2 },
                                ];

                                function categorize({price}) {
                                    if (price > 100)
                                        return 'expensive'
                                    return 'cheap'
                                }

                                console.log(Object.groupBy(products, categorize))
                            </code>
                        </pre>
                    </div>
                    <div class="attach-top">
                        <div class="language-control">
                            <span></span>
                        </div>
                        <pre>
                            <code class="code-block" data-language="javascript">
                                // Output:
                                {
                                    'cheap': [
                                        { name: 'Mug', price: 27.5 },
                                        { name: 'Fork', price: 2 }
                                    ],
                                    'expensive': [
                                        { name: 'Laptop', price: 500 },
                                        { name: 'Headphones', price: 199.99 }
                                    ]
                                }
                            </code>
                        </pre>
                    </div>
                </div>
            </section>
            <section>
                <h2>
                    Array mutations
                </h2>
                <p>
                    JavaScript offers several methods for manipulating arrays. However, traditional methods like sort, splice, and reverse modify the original array, and that's not a consistent behavior, since other methods like <span class="keyword">map</span>, <span class="keyword">filter</span> and <span class="keyword">reduce</span> don't do that.
                    <br>
                    ECMAScript 2023 introduced a set of new methods that prioritize immutability: <span class="keyword">toSorted</span>, <span class="keyword">toSpliced</span>, and <span class="keyword">toReversed</span>. These methods create new arrays, leaving the original data untouched.
                </p>
                <div>
                    <div>
                        <div class="language-control">
                            <span></span>
                        </div>
                        <pre>
                            <code class="code-block" data-language="javascript">
                                const numbers = [3, 1, 4, 5, 2];

                                const sortedNumbers = numbers.toSorted((a, b) => a - b);

                                console.log(numbers); // [3, 1, 4, 5, 2] (remains unchanged)
                                console.log(sortedNumbers); // [1, 2, 3, 4, 5]
                            </code>
                        </pre>
                    </div>
                </div>
            </section>
        </article>
    </main>
</body>

</html>