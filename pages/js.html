<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta name="theme-color" content="#54342f">
    <link rel="icon" href="../public/icons/favicon.svg" type="image/x-icon">
    <link rel="stylesheet" href="../css/global.css">
    <link rel="stylesheet" href="../css/styles.css">
    <link rel="stylesheet" href="../css/prism.css">
    <script src="../js/nav.js" defer></script>
    <script src="../js/prism.js" defer></script>
    <script src="../js/sidebar.js" defer></script>
    <title>DevWonders</title>
</head>

<body>
    <header>
        <a href="../index.html">
            <h1>DevWonders</h1>
            <img src="../public/icons/favicon.svg" alt="Logo">
        </a>
        <div id="dropdown_container">
            <img src="../public/icons/git.svg" alt="Git logo">
            <nav>
                <ul>
                    <li><a style="--color: var(--html)" href="html.html">HTML</a></li>
                    <li><a style="--color: var(--css)" href="css.html">CSS</a></li>
                    <li><a style="--color: var(--html)" href="git.html">Git</a></li>
                </ul>
            </nav>
        </div>
        <div class="socials">
            <a target="_blank" href="https://github.com/LDrawe/devwonders">
                <img class="socials" src="../public/icons/github.svg" alt="Github Logo" style="--right: 100px">
            </a>
            <a target="_blank"
                href="https://www.figma.com/file/MgxD8j0oAzcquhuCH9x4Hq/DevWonders?type=design&node-id=4%3A9&mode=design&t=KMVYThqEfEpXnkc6-1">
                <img class="socials" src="../public/icons/figma.svg" alt="Figma Logo" style="--right: 40px">
            </a>
        </div>
    </header>
    <main>
        <nav>
            <ul>
            </ul>
        </nav>
        <article>
            <button id="rtn-btn" title="Return to top" type="button">
                <img src="../public/icons/up.svg" alt="Return to top" height="30">
            </button>
            <button id="sidebar-Control" title="Toggle sidebar" type="button">
                <span></span>
            </button>
            <section>
                <h2>
                    Numeric separator
                </h2>
                <p>
                    Small numbers are easy and quick to read. But what about large ones? Let's say
                    1000000.
                    You probably have seen a large number like this while coding. Thankfully, javascript has
                    a way to make these more readable, you can use underlines to separate into groups for better readability. 
                    Don't worry, it doesn't change their behaviour, it's only for visual use
                </p>
                <div>
                    <div>
                        <div class="language-control">
                            <span></span>
                        </div>
                        <pre>
                            <code class="language-javascript code-block">
                                console.log(1_000_000)
                            </code>
                        </pre>
                    </div>
                </div>
            </section>
            <section>
                <h2>
                    Delete
                </h2>
                <p>
                    If you have an object and need to delete a property from it, you may be tempted to use the <span class="keyword">delete</span>
                    keyword. And that's fine, but you can solve this in a more elegant and safer way by using
                    destructuring.
                </p>
                <div>
                    <div>
                        <div class="language-control">
                            <span></span>
                        </div>
                        <pre>
                            <code class="language-javascript code-block">
                                const foo = {
                                    positionX: 50,
                                    positionY: 20,
                                    positionZ: 2
                                }
                                const { positionX, ...bar } = foo
                                console.log(bar)
                            </code>
                        </pre>
                    </div>
                </div>
            </section>
            <section>
                <h2>
                    isNan
                </h2>
                <p>
                    The <span class="keyword">isNan</span> function in JavaScript is used to determine if a value is Not a Number (NaN). It's
                    important to distinguish between NaN and other <span class="keyword">falsy</span> values like 0, empty strings, and false. For example, if we use the bang operator to check for a valid input, because javascript sees 0 as a <span class="keyword">falsy</span> value, it would flip a <span class="keyword">falsy</span> value to <span class="keyword truthy">true</span>, even if it's a valid one in our scenario. That's when you should use the isNan function
                </p>
                <div>
                    <div>
                        <div class="language-control">
                            <span></span>
                        </div>
                        <pre>
                            <code class="language-javascript code-block">
                                let numberOfMessages = 0
                                // This would run, even though it's a valid input
                                if(!numberOfMessages) {
                                    throw new Error('Invalid value')
                                }
                            </code>
                        </pre>
                    </div>
                    <div>
                        <div class="language-control">
                            <span></span>
                        </div>
                        <pre>
                            <code class="language-javascript code-block">
                                let numberOfMessages = 0
                                if(isNan(numberOfMessages)) {
                                    throw new Error('Invalid value')
                                }
                                console.log(`You have ${numberOfMessages} unread messages`)
                            </code>
                        </pre>
                    </div>
                </div>
            </section>
            <section>
                <h2>
                    Nullish Coalescing
                </h2>
                <p>
                    The <span class="keyword">||</span> (OR) operator  is used to provide default values or check for truthy
                    conditions. We often rely on it because of its simplicity. However, it can
                    sometimes lead to unexpected behavior, especially when dealing with the number 0
                </p>
                <div>
                    <div>
                        <div class="language-control">
                            <span></span>
                        </div>
                        <pre>
                            <code class="language-javascript code-block">
                                let myTax = 0

                                const finalTax = myTax || 10 // Default tax if none is given
                                console.log(finalTax) // Output: 10 
                            </code>
                        </pre>
                    </div>
                </div>
                <p>
                    The intention here is to provide a base tax (10 dollars) if no value is passed. But the <span class="keyword">||</span> operator sees the tax amount as <span class="keyword">falsy</span> (because it's 0) and assigns the default value (10). This can be a bug if you actually want the code to recognize 0 as a valid value and not provide a tax. This is when the <span class="keyword">??</span> operator comes in hand. It checks if the value on the left side is either <span class="keyword">null</span> or <span class="keyword">undefined</span>. If it is, then it uses the value on the right side. This makes it perfect for setting defaults without getting tripped up by <span class="keyword">falsy</span> values like 0
                </p>
                <div>
                    <div>
                        <div class="language-control">
                            <span></span>
                        </div>
                        <pre>
                            <code class="language-javascript code-block">
                                let myTax = 0

                                const finalTax = myTax ?? 10
                                console.log(finalTax) // Output: 0 
                            </code>
                        </pre>
                    </div>
                </div>
            </section>
            <section>
                <h2>
                    Optional chaining
                </h2>
                <p>
                    Optional chaining is a powerful feature introduced in ES6+ that allows you to safely
                    access nested properties within an object. It avoids long if statement to check for the properties individually and errors when dealing with potentially
                    undefined values in the chain.
                </p>
                <div>
                    <div>
                        <div class="language-control">
                            <span></span>
                        </div>
                        <pre>
                            <code class="language-javascript code-block">
                                const user = {
                                    name: 'Alice',
                                    address: {
                                      street: '123 Main St',
                                      state: 'California'
                                    },
                                  }
                                  
                                // Even if property is undefined, it's safe to access
                                const street = user?.address?.street
                                console.log(street) // Output: "123 Main St" 
                            </code>
                        </pre>
                    </div>
                </div>
            </section>
            <section>
                <h2>
                    Inline catch
                </h2>
                <p>
                    When dealing with code that has promises, developers tend to encapsulate the entire block in a <span class="keyword">Try/Catch</span> block to prevent any errors. But when dealing with simple promises, this becomes unnecessary and adds a bit of nesting too. Instead, if it's a simple error treating, you can just catch it
                </p>
                <div>
                    <div>
                        <div class="language-control">
                            <span></span>
                        </div>
                        <pre>
                            <code class="language-javascript code-block">
                                const data = fetch('google.com').catch(error => console.error(error))
                            </code>
                        </pre>
                    </div>
                </div>
            </section>
            <section>
                <h2>
                    Block scope
                </h2>
                <p>
                    Variables declared within a block are only accessible from within that specific block. This creates a well-defined scope for each variable, preventing unintended interactions with identically named variables in other parts of your code.
                </p>
                <div>
                    <div>
                        <div class="language-control">
                            <span></span>
                        </div>
                        <pre>
                            <code class="language-javascript code-block">
                                let count = 5
                                {
                                    let count = 0
                                    console.log(count) // Output: 0
                                }
                                console.log(count) // Output: 5
                            </code>
                        </pre>
                    </div>
                </div>
            </section>
            <section>
                <h2>
                    In Keyword
                </h2>
                <p>
                    The <span class="keyword">in</span> keyword is a handy operator in JavaScript that checks if a property exists as a key within an object.
                </p>
                <div>
                    <div>
                        <div class="language-control">
                            <span></span>
                        </div>
                        <pre>
                            <code class="language-javascript code-block">
                                const person = { name: 'Alice', age: 30 }
                                console.log('name' in person) // true
                                console.log('city' in person) // false
                            </code>
                        </pre>
                    </div>
                </div>
            </section>
            <section>
                <h2>
                    Dynamic Import
                </h2>
                <p>
                    Imagine a scenario where you only want to load specific code based on certain
                    conditions. JavaScript's dynamic import functionality allows you to import modules at runtime.
                </p>
                <div>
                    <div>
                        <div class="language-control">
                            <span></span>
                        </div>
                        <pre>
                            <code class="language-javascript code-block">
                                if(userIsAdmin) {
                                    const lazyModule = await import('./admin.js')
                                }
                            </code>
                        </pre>
                    </div>
                </div>
            </section>
            <section>
                <h2>
                    Promise.all
                </h2>
                <p>
                    Waiting for multiple asynchronous operations can be sometimes inneficient.Let's say you have to fetch a list of users and posts from an API. The data retrived from one is not necessary to fetch the other.
                    <br>
                    <span class="keyword">Promise.all()</span> helps you get both results at once: It allows you to execute them
                    in parallel and provides a single promise that resolves when all the individual promises have
                    resolved.
                </p>
                <div>
                    <div>
                        <div class="language-control">
                            <span></span>
                        </div>
                        <pre>
                            <code class="language-javascript code-block">
                                // We're waiting users to finish before fetching the posts
                                // Even if we don't need the users data to fetch posts
                                const users = await fetch('https://api.example.com/users/')
                                const posts = await fetch('https://api.example.com/posts/')
                            </code>
                        </pre>
                    </div>

                    <div>
                        <div class="language-control">
                            <span></span>
                        </div>
                        <pre>
                            <code class="language-javascript code-block">
                                // Now we are fetching the users and posts at the sime time
                                
                                const [users, posts] = await Promise.all([
                                    fetch('https://api.example.com/users/'),
                                    fetch('https://api.example.com/posts/')
                                ])
                            </code>
                        </pre>
                    </div>
                </div>
            </section>
            <section>
                <h2>
                    Object.groupBy
                </h2>
                <p>
                    <span class="keyword">Object.groupBy()</span> allows you to categorize these objects based on a specific property. The end result is an object organized in groups. Let's take an example, you have a array of products and want to separate them between cheap and expensive:
                </p>
                <div>
                    <div>
                        <div class="language-control">
                            <span></span>
                        </div>
                        <pre>
                            <code class="language-javascript code-block">
                                const products = [
                                    { name: 'Laptop', price: 500.00 },
                                    { name: 'Mug', price: 27.50 },
                                    { name: 'Headphones', price: 199.99 },
                                    { name: 'Fork', price: 2 },
                                ]

                                function categorize({price}) {
                                    if (price > 100)
                                        return 'expensive'
                                    return 'cheap'
                                }

                                console.log(Object.groupBy(products, categorize))
                            </code>
                        </pre>
                    </div>
                    <div>
                        <div class="language-control">
                            <span></span>
                        </div>
                        <pre>
                            <code class="language-javascript code-block">
                                // Output:
                                {
                                    'cheap': [
                                        { name: 'Mug', price: 27.5 },
                                        { name: 'Fork', price: 2 }
                                    ],
                                    'expensive': [
                                        { name: 'Laptop', price: 500 },
                                        { name: 'Headphones', price: 199.99 }
                                    ]
                                }
                            </code>
                        </pre>
                    </div>
                </div>
            </section>
            <section>
                <h2>
                    Array mutations
                </h2>
                <p>
                    JavaScript offers several methods for manipulating arrays. However, traditional methods like <span class="keyword">sort</span>, <span class="keyword">splice</span>, and <span class="keyword">reverse</span> modify the original array, and that's not a consistent behavior, since other methods like <span class="keyword">map</span>, <span class="keyword">filter</span> and <span class="keyword">reduce</span> don't do that.
                    <br>
                    ECMAScript 2023 introduced a set of new methods that prioritize immutability: <span class="keyword">toSorted</span>, <span class="keyword">toSpliced</span>, and <span class="keyword">toReversed</span>. These methods create new arrays, leaving the original data untouched.
                </p>
                <div>
                    <div>
                        <div class="language-control">
                            <span></span>
                        </div>
                        <pre>
                            <code class="language-javascript code-block">
                                const numbers = [3, 1, 4, 5, 2]
                                const sortedNumbers = numbers.toSorted((a, b) => a - b)
                                <!--  -->
                                console.log(numbers) // [3, 1, 4, 5, 2] (remains unchanged)
                                console.log(sortedNumbers) // [1, 2, 3, 4, 5]
                            </code>
                        </pre>
                    </div>
                </div>
            </section>
        </article>
    </main>
</body>

</html>